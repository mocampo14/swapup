
public class Ocampo_Project2 
{
		// Use the following code to test your results
		static final int N = 4;

		public static void main(String[] args) 
		{

			testSLList();
			testDLList();
			testStackQueue();
		}

		static void testSLList() 
		{
			
				// prints out name, class, and project number
			   System.out.println("Mico Ocampo");
			   System.out.println("CS 380 - PROJECT 2");
			   System.out.println();
			   System.out.println("------------------");

			System.out.println("SINGLY-LINKED LIST:");

			SLList list1 = new SLList();

			for (int i = 0; i < N; i++)
				list1.append(new SLNode(i));
			for (double d = N; d < 2 * N; d++)
				list1.append(new SLNode(d));

			System.out.println(list1);


			SLNode temp = list1.search(0);
			System.out.println(temp);

			list1.removeAfter(temp);
			System.out.println(list1);

			list1.insertAfter(temp, new SLNode(1000));
			System.out.println(list1);

			System.out.println();
		}

		static void testDLList() 
		{

			System.out.println("DOUBLY-LINKED LIST:");

			DLList list2 = new DLList();

			for (int i = 0; i < N; i++) 
				list2.append(new DLNode(i));
			for (double d = N; d < 2 * N; d++)
				list2.append(new DLNode(d));

			System.out.println(list2);

			DLNode temp = list2.search(0);
			System.out.println(temp);


			list2.insertAfter(temp, new DLNode(2000));
			System.out.println(list2);

			list2.remove(temp);
			System.out.println(list2);

			System.out.println();
		}

		public static void testStackQueue() 
		{

			System.out.println("STACK:");

			SLList stack1 = new SLList();
			final int M = 10;
			for (int i = 1; i < M; i++) 
			{
				System.out.print("push " + i + ": ");
				stack1.push(i);
				System.out.println(stack1);
			}
			for (int i = 1; i < M; i++) 
			{
				System.out.print(stack1.pop() + " pop: ");
				System.out.println(stack1);
			}
			System.out.println();

		System.out.println("QUEUE:");

			SLList queue1 = new SLList();

			for (int i = 1; i < M; i++) 
			{
				System.out.print("enqueue " + i + ": ");
				queue1.enqueue(i);
				System.out.println(queue1);
			}

			for (int i = 1; i < M; i++) 
			{
				System.out.print(queue1.dequeue() + " dequeue: ");
				System.out.println(queue1);
			}
			System.out.println();
		}

		// Define class SLNode
		static class SLNode // go for SLNode first 
		{
			Object data;
			SLNode next;

			SLNode(Object o)
			{
				data = o;
				next = null;
			}

			public String toString() 
			{
				return "[" + data.toString() + "]"; 
			}
		}

		// stackPush, stackPop, queuePush,
		// push, pop, enqueue, dequeue

		// Define class SLList
		static class SLList 
		{
			private SLNode head;
			private SLNode tail;

			SLList() 
			{
				head = null;
				tail = null;
			}

			// Define public void append
			public void append(SLNode newNode)
			{
				if (head == null) 
				{ // List empty
					head = newNode;
					tail = newNode;
				}
				else {
					tail.next = newNode;
					tail = newNode;
				}
			}

			// Define prepend()
			public void prepend(SLNode newNode) 
			{ 

				if (head == null) 
				{ // list empty
					head = newNode;
					tail = newNode;
				}
				else 
				{
					newNode.next = head;
					head = newNode;

				}
			}

			// Define insertAfter()
			public void insertAfter(SLNode currNode, SLNode newNode)
			{

				if (head == null || currNode.next == tail)
					append(newNode);
				else{
					newNode.next = currNode.next;
					currNode.next = newNode;
				}
			}

			// Define removeAfter()
			public void removeAfter(SLNode curNode)
			{

				SLNode sucNode = null;

				// (curNode is 0 && list->head is not 0) 
				if (curNode == null)
				{
					if (head != null) {


						sucNode = head.next; // sucNode = list->head->next
						head = sucNode;

						if (sucNode == null) // Removed last item
						{
							tail = null; // list->tail = 0
						}
					}
				} 

				// (curNode->next is not 0)
				else if (curNode.next != null) 
				{
					sucNode = curNode.next.next;
					curNode.next = sucNode;

					// (sucNode is 0)
					if (sucNode == null ) // Removed tail
					{
						tail = curNode; // list->tail = curNode
					}
				}
			}

			// Define public SLNode search(Object key)
			public SLNode search(Object key) 
			{
				SLNode curNode =head;
				while (curNode != null) 
				{
					if (curNode.data.equals(key)) 
					{
						return curNode;
					}
					curNode = curNode.next;

				}
				return null;
			}

			/**
			 * Define public String toString() that returns a String by 
			 * traversing the list and getting the toString of each of the nodes
			 */
			public String toString()
			{
				SLNode curNode = head; // Start at head
				String temp = "";
				while (curNode != null) 
				{
					temp += curNode + "->"; // Separate two node with â€œ->â€
					curNode = curNode.next;
				}
				return temp + "X";
			}

			public void stackPush(SLNode newItem)
			{
				prepend(newItem); 
			}

			public SLNode stackPop()
			{
				if (head !=null)
				{
					SLNode poppedItem = head; // Copy list head (top of stack)
					removeAfter(null); // Remove list head  
					return poppedItem; // Return popped item
				}
				return null;
			}

			public void queuePush(SLNode newItem)
			{
				append(newItem); 

			}
			public SLNode queuePop()
			{
				SLNode poppedItem = head; // Copy list head (top of stack)
				removeAfter(null); // Remove list head  
				return poppedItem; // Return popped item
			}
			public void push(Object o)
			{
				stackPush(new SLNode(o)); 
			}
			public Object pop()
			{
				SLNode temp = stackPop();

				if (temp != null) 

					return temp.data;

				return null;

			}

			public void enqueue(Object o)
			{
				queuePush(new SLNode(o)); // Insert as list head
			}
			public Object dequeue()
			{
				return queuePop().data; // Insert as list head
			}
		}



		// Define class DLNode
		static class DLNode
		{
			// Define local variables
			Object data;
			DLNode prev;
			DLNode next;

			// Define constructor DLNode(Object o) 
			DLNode(Object o)
			{
				data =o;
				prev = null;
				next = null;
				next = null;
			}

			// Define toString method public String toString() 
			public String toString()
			{

				// that returns the String â€œ[â€œ + data.toString() + â€œ]â€
				return "[" + data.toString() + "]";
			}
		}

		// Define class DLList
		static class DLList 
		{
			// Define local variables
			private DLNode head;
			private DLNode tail;

			// Define constructor DLList()
			DLList() 
			{
				head = null;
				tail = null;
			}

			// Define public void append
			public void append(DLNode Nodes)
			{


				if(head == null){
					head = Nodes;
					tail = Nodes;
				}
				else{
					tail.next =Nodes;
					Nodes.prev = tail;
					tail = Nodes;
				}
			}

			// Define prepend()
			public void prepend(DLNode Nodes)
			{


				if (head ==null)
					append(Nodes);
				else
				{
					Nodes.next =head;
					head.prev =Nodes;
					head =Nodes;
				}
			}

			// Define insertAfter()
			public void insertAfter(DLNode currNode, DLNode newNode)
			{

				if (head == null || currNode.next == tail)
					append(newNode);
				else {
					DLNode temp = currNode.next;
					newNode.next = temp;
					newNode.prev = currNode;
					currNode.next = newNode;
					temp.prev = newNode;
				}
			}

			// Define remove() 
			public void remove(DLNode Nodes)
			{
				DLNode nNode = Nodes.next;
				DLNode pNode = Nodes.prev;

				// (sucNode is not 0)
				if (nNode != null)
					nNode.prev = pNode; // sucNode->prev = predNode

				// (predNode is not 0)
				if (pNode != null)
					pNode.next = nNode; // predNode->next = sucNode

				// curNode == list->head)
				if (Nodes == head) // Removed head
					head = nNode; // list->head = sucNode

				// (curNode == list->tail)
				if (Nodes == tail) // Removed tail
					tail = pNode; // list->tail = predNode
			}

			// Define public DLNode search(Object key)
			public DLNode search(Object key)
			{

				DLNode curNode = head;
				while (curNode != null){
					if (curNode.data.equals(key))
					{
						return curNode;
					}
					curNode = curNode.next;
				}
				return null;
			}

			/**
			 *  Define public String toString() that returns a String by traversing
			 *  the list and getting the toString of each of the nodes
			 */
			@Override
			public String toString()
			{
				if (head == null){return super.toString();
				}
				DLNode Nodes = head;
				String s = "X<-"; // Before the first node print â€œX<-â€œ
				do
				{
					s += Nodes.toString();
					if (Nodes.next == null)
						s += "->"; // After the last node print â€œ->Xâ€
					else
						s+= "<=>"; // Separate two node with â€œ<=>â€
					Nodes = Nodes.next;
				}

				while (Nodes != null);
				return s + "X";
			}
		}
	}